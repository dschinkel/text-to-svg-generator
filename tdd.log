PLAN:
1. Frontend: Hook - useSVG (TDD)
   RED:
   - Test name: fetches outer outline svg
   - Location: src/client/components/useSVG.test.ts
   - Intent: Update the hook to fetch and return outerOutlineSVG from the backend API using type=outer.
   GREEN:
   - Minimal implementation: Update useSVG.ts to fetch all three types (base, tight, outer).
   - Files expected to change: src/client/components/useSVG.ts
   COMMIT:
   - Proposed message: feat: FR.3.3: Step 1: Frontend: Hook: fetches outer outline svg
   REFACTOR:
   - Candidate refactors: Consolidate fetch logic to reduce duplication.
2. Backend: Use Case - Generate Outer Outline SVG (TDD)
   RED:
   - Test name: generates outer outline svg
   - Location: src/service/svg/use-cases/GenerateOuterOutlineSVG.test.ts
   - Intent: Define a use case that orchestrates outer outline generation.
   GREEN:
   - Minimal implementation: Create GenerateOuterOutlineSVG use case using the shared font loader.
   - Files expected to change: src/service/svg/use-cases/GenerateOuterOutlineSVG.ts
   COMMIT:
   - Proposed message: feat: FR.3.3: Step 2: Service: UseCase: generates outer outline svg
   REFACTOR:
   - Candidate refactors: Ensure minimal duplication with other SVG use cases.
3. Backend: Domain - SVG Generation (Outer Contour) (TDD)
   RED:
   - Test name: generates outer outline svg from text
   - Location: src/service/svg/domain/svgGenerator.test.ts
   - Intent: Update svgGenerator to support outer type with a larger stroke.
   GREEN:
   - Minimal implementation: Add outer case to svgGenerator with a larger stroke-width and padding.
   - Files expected to change: src/service/svg/domain/svgGenerator.ts
   COMMIT:
   - Proposed message: feat: FR.3.3: Step 3: Service: Domain: generates outer outline svg from text
   REFACTOR:
   - Candidate refactors: Extract common path rendering logic to reduce duplication.
4. Backend Integration (Non-TDD)
   - Goal: Update FontController, app.ts, and index.ts to expose the new use case.
   - Changes: src/service/fonts/controllers/fontController.ts, src/service/app.ts, src/service/index.ts.
5. App Integration
   - Goal: Add another SVGPreview component in App.tsx for the Outer Outline SVG.
   - Changes: src/client/App.tsx.
   - Verification: Manual verification in browser.
6. Cleanup & Verification
   - Run all tests.
   - Fix linting errors.
   - Mark task as [COMPLETED] in tasks.md.
   COMMIT:
   - Proposed message: feat: FR.3.3: cleanup: outer outline svg generation

GOAL: shows fonts
PLAN STEP: 1
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/components/FontSelector.test.tsx - shows fonts
CHANGESET:
    it('shows fonts', () => {
    const fonts = [
      { id: 'octin-sports', name: 'Octin Sports' },
      { id: 'campus-mn', name: 'Campus MN' }
    ];
    
    const fakeRepository = {
      getFonts: jest.fn().mockResolvedValue(fonts)
    };

    const useFonts = (repository: any) => ({
      fonts,
      loading: false,
      error: null
    });

    render(
      <FontSelector 
        useFonts={useFonts} 
        repository={fakeRepository} 
        onSelect={() => {}} 
      />
    );

    expect(screen.getByText('Octin Sports')).toBeInTheDocument();
    expect(screen.getByText('Campus MN')).toBeInTheDocument();
  });

COMMANDS RUN: yarn jest src/client/fonts/components/FontSelector.test.tsx
TEST OUTPUT: RED - TypeError: Cannot read properties of undefined (reading 'map')

NEXT STEP: Modify FontSelector to accept useFonts and repository props and use them.

=== GREEN PHASE ===
CHANGESET:
export interface FontSelectorProps {
  useFonts: (repository: any) => { fonts: Font[]; loading: boolean; error: Error | null };
  repository: any;
  onSelect: (font: Font) => void;
}

export const FontSelector = ({ useFonts, repository, onSelect }: FontSelectorProps) => {
  const { fonts } = useFonts(repository);

  return (
    <div>
      <select
        onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
          const font = fonts.find(f => f.id === e.target.value);
          if (font) onSelect(font);
        }}
      >

COMMANDS RUN: yarn jest src/client/fonts/components/FontSelector.test.tsx
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 6: Frontend: Inject hook into FontSelector
USER DECISION: 

GOAL: shows font selector
PLAN STEP: 2
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/App.test.tsx - shows font selector
CHANGESET:
import * as React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';
import '@testing-library/jest-dom';

describe('App', () => {
  it('shows font selector', () => {
    render(<App />);
    expect(screen.getByText('Select a font')).toBeInTheDocument();
  });
});

COMMANDS RUN: yarn jest src/client/App.test.tsx
TEST OUTPUT: RED - Unable to find an element with the text: Select a font.

NEXT STEP: Update App.tsx to render FontSelector.

=== GREEN PHASE ===
CHANGESET:
import { FontSelector } from './fonts/components/FontSelector';
import { useFonts } from './fonts/hooks/useFonts';

const App = () => {
  const fakeRepository = {
    getFonts: async () => []
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-slate-50 text-slate-900">
      <h1 className="text-3xl font-bold mb-8">Text to SVG Generator</h1>
      <FontSelector 
        useFonts={useFonts} 
        repository={fakeRepository} 
        onSelect={() => {}} 
      />
    </div>
  );
};

COMMANDS RUN: yarn jest src/client/App.test.tsx
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 7: Frontend: Render font selector in App
USER DECISION: 

GOAL: fetches fonts
PLAN STEP: 3
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/repositories/fontRepository.test.ts - fetches fonts
CHANGESET:
import { fontRepository } from './fontRepository';

describe('fontRepository', () => {
  it('fetches fonts', async () => {
    const fakeFonts = [{ id: 'octin-sports', name: 'Octin Sports' }];
    
    global.fetch = jest.fn().mockResolvedValue({
      ok: true,
      json: async () => fakeFonts
    });

    const repository = fontRepository();
    const fonts = await repository.getFonts();

    expect(fonts).toEqual(fakeFonts);
    expect(global.fetch).toHaveBeenCalledWith('/api/fonts');
  });
});

COMMANDS RUN: yarn jest src/client/fonts/repositories/fontRepository.test.ts
TEST OUTPUT: RED - Cannot find module './fontRepository'

NEXT STEP: Create fontRepository with getFonts method using fetch.

=== GREEN PHASE ===
CHANGESET:
export const fontRepository = () => {
  const getFonts = async (): Promise<any[]> => {
    const response = await fetch('/api/fonts');
    if (!response.ok) {
      throw new Error(`Failed to fetch fonts: ${response.statusText}`);
    }
    return await response.json();
  };

  return {
    getFonts
  };
};

COMMANDS RUN: yarn jest src/client/fonts/repositories/fontRepository.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 8: Frontend: Client font repository
USER DECISION: 

GOAL: lists fonts
PLAN STEP: 4
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/service/server/app.test.ts - lists fonts
CHANGESET:
import request from 'supertest';
import { createApp } from './app';

describe('server', () => {
  it('lists fonts', async () => {
    const fonts = [{ id: 'octin-sports', name: 'Octin Sports' }];
    const fakeController = {
      getFonts: jest.fn().mockResolvedValue(fonts)
    };

    const app = createApp(fakeController);
    const response = await request(app.callback()).get('/api/fonts');

    expect(response.status).toBe(200);
    expect(response.body).toEqual(fonts);
  });
});

COMMANDS RUN: yarn jest src/service/server/app.test.ts
TEST OUTPUT: RED - Cannot find module './app'

NEXT STEP: Create createApp in app.ts using Koa and koa-router.

=== GREEN PHASE ===
CHANGESET:
import Koa from 'koa';
import Router from 'koa-router';

export interface FontController {
  getFonts: () => Promise<any[]>;
}

export const createApp = (fontController: FontController) => {
  const app = new Koa();
  const router = new Router();

  router.get('/api/fonts', async (ctx) => {
    ctx.body = await fontController.getFonts();
  });

  app.use(router.routes()).use(router.allowedMethods());

  return app;
};

COMMANDS RUN: yarn jest src/service/server/app.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 9: Service: Expose fonts
USER DECISION: 

=== CLEANUP & VERIFICATION ===
- Ran full test suite: 9 passed
- Fixed dependency injection in FontSelector and App
- Configured Vite proxy and Koa server
- Verified all components are wired correctly

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.1.1: cleanup: font selector integration
USER DECISION: 
PLAN STEP: 1.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/service/fonts/data/AdobeTypekitClient.test.ts - fetches font family metadata from adobe
CHANGESET:
import { AdobeTypekitClient } from './AdobeTypekitClient';

describe('AdobeTypekitClient', () => {
  it('fetches font family metadata from adobe', async () => {
    const mockApiResponse = {
      family: {
        id: 'gscg',
        name: 'Octin Sports',
        slug: 'octin-sports',
      }
    };

    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockApiResponse),
      })
    );

    const client = new AdobeTypekitClient('fake-token');
    const family = await client.getFamily('gscg');

    expect(family).toEqual(mockApiResponse.family);
    expect(global.fetch).toHaveBeenCalledWith(
      'https://typekit.com/api/v1/json/families/gscg',
      expect.objectContaining({
        headers: expect.objectContaining({
          'X-Typekit-Token': 'fake-token'
        })
      })
    );
  });
});

COMMANDS RUN: yarn jest src/service/fonts/data/AdobeTypekitClient.test.ts
TEST OUTPUT: RED - Cannot find module './AdobeTypekitClient'

NEXT STEP: Create AdobeTypekitClient with getFamily method using fetch

=== GREEN PHASE ===
CHANGESET:
export class AdobeTypekitClient {
  private readonly baseUrl = 'https://typekit.com/api/v1/json';

  constructor(private readonly token: string) {}

  async getFamily(familyId: string): Promise<any> {
    const response = await fetch(`${this.baseUrl}/families/${familyId}`, {
      headers: {
        'X-Typekit-Token': this.token
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch font family ${familyId}: ${response.statusText}`);
    }

    const data = await response.json();
    return data.family;
  }
}

COMMANDS RUN: yarn jest src/service/fonts/data/AdobeTypekitClient.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: backend: adobe typekit client
USER DECISION: committed (updated message: feat: FR.1.1: backend: adobe typekit client - gets Octin, Campus MN fonts from the typekit api)

=== REFACTOR ===
CHANGESET:
Refactored to JS modules and separated fetch and save behavior into their own composed functions.

COMMANDS RUN: yarn jest src/service/fonts/repositories/fontRepository.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT (REFACTOR) ===
PROPOSED COMMIT: refactor to JS modules and separate fetch and save behavior into their own composed functions
USER DECISION: committed

GOAL: lists fonts
PLAN STEP: 4.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/service/fonts/controllers/fontController.test.ts, src/service/fonts/use-cases/listFontsCommand.test.ts
CHANGESET:
[New test files created]

COMMANDS RUN: yarn jest src/service/fonts/controllers/fontController.test.ts
TEST OUTPUT: RED (before implementation)

=== GREEN PHASE ===
CHANGESET:
[src/service/fonts/controllers/fontController.ts, src/service/fonts/use-cases/listFontsCommand.ts]

COMMANDS RUN: yarn jest src/service/fonts/controllers/fontController.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: backend: list fonts command and controller
USER DECISION: committed

GOAL: provides available fonts
PLAN STEP: 4.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/hooks/useFonts.test.ts - provides available fonts
CHANGESET:
import { renderHook, waitFor } from '@testing-library/react';
import { useFonts } from './useFonts';

describe('useFonts', () => {
  it('provides available fonts', async () => {
    const fonts = [{ id: 'octin-sports', name: 'Octin Sports' }];
    const fakeRepository = {
      getFonts: jest.fn().mockResolvedValue(fonts)
    };

    const { result } = renderHook(() => useFonts(fakeRepository));

    await waitFor(() => expect(result.current.fonts).toEqual(fonts));
  });
});

COMMANDS RUN: yarn jest src/client/fonts/hooks/useFonts.test.ts
TEST OUTPUT: RED - Cannot find module './useFonts'

=== GREEN PHASE ===
CHANGESET:
import { useState, useEffect } from 'react';

export interface ClientFontRepository {
  getFonts: () => Promise<any[]>;
}

export const useFonts = (repository: ClientFontRepository) => {
  const [fonts, setFonts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let mounted = true;

    const loadFonts = async () => {
      try {
        const data = await repository.getFonts();
        if (mounted) {
          setFonts(data);
          setLoading(false);
        }
      } catch (e) {
        if (mounted) {
          setError(e as Error);
          setLoading(false);
        }
      }
    };

    loadFonts();

    return () => {
      mounted = false;
    };
  }, [repository]);

  return { fonts, loading, error };
};

COMMANDS RUN: yarn jest src/client/fonts/hooks/useFonts.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 4: Frontend: Client Font Repository & Hook
USER DECISION: committed (updated message: feat: FR.1.1: Step 4: Frontend: Client Font Repository & Hook)

GOAL: shows list of fonts to chose from
PLAN STEP: 5.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/components/FontSelector.test.tsx - shows list of fonts to chose from
CHANGESET:
[Created test with JSX syntax]

COMMANDS RUN: yarn jest src/client/fonts/components/FontSelector.test.tsx
TEST OUTPUT: RED - TypeError: Cannot read properties of undefined (reading 'createElement')

=== GREEN PHASE ===
CHANGESET:
[Implemented FontSelector.tsx using JSX]

COMMANDS RUN: yarn jest src/client/fonts/components/FontSelector.test.tsx
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.1: Step 5: Frontend: Select a font
USER DECISION: committed

=== CLEANUP & VERIFICATION ===
- Ran full test suite (5/5 passing)
- Removed root test/ folder as requested
- Updated jest.config.js to remove reference to test/setup.ts
- Verified compilation with tsc

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.1.1: cleanup: full-stack font selection
USER DECISION: committed

GOAL: adds a font
PLAN STEP: 2
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/hooks/useFonts.test.ts - adds a font
CHANGESET:
  it('adds a font', async () => {
    const initialFonts = [{ id: 'octin-sports', name: 'Octin Sports' }];
    const newFont = { id: 'campus-mn', name: 'Campus MN' };
    
    const fakeRepository = {
      getFonts: async () => initialFonts,
      addFont: async (name: string) => newFont
    };

    const { result } = renderHook(() => useFonts(fakeRepository));
    
    await waitFor(() => expect(result.current.fonts).toEqual(initialFonts));

    await act(async () => {
      await result.current.addFont('Campus MN');
    });

    expect(result.current.fonts).toEqual([...initialFonts, newFont]);
  });

COMMANDS RUN: yarn jest src/client/fonts/hooks/useFonts.test.ts
TEST OUTPUT: RED - TypeError: result.current.addFont is not a function

NEXT STEP: Update useFonts hook to return addFont function that calls repository.addFont and updates state.

=== GREEN PHASE ===
CHANGESET:
  const addFont = async (name: string) => {
    try {
      const newFont = await repository.addFont(name);
      setFonts(prev => [...prev, newFont]);
    } catch (e) {
      setError(e as Error);
    }
  };

  return { fonts, loading, error, addFont };

COMMANDS RUN: yarn jest src/client/fonts/hooks/useFonts.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.2: Step 2: Frontend: Hook: adds a font
USER DECISION: committed

GOAL: adds a font
PLAN STEP: 3
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/fonts/repositories/fontRepository.test.ts - adds a font
CHANGESET:
  it('adds a font', async () => {
    const newFont = { id: 'campus-mn', name: 'Campus MN' };
    let calledUrl = '';
    let calledOptions: any = {};
    
    global.fetch = (async (url: string, options: any) => {
      calledUrl = url;
      calledOptions = options;
      return {
        ok: true,
        json: async () => newFont
      };
    }) as any;

    const repository = fontRepository();
    const result = await repository.addFont('Campus MN');

    expect(result).toEqual(newFont);
    expect(calledUrl).toBe('/api/fonts');
    expect(calledOptions.method).toBe('POST');
    expect(calledOptions.headers['Content-Type']).toBe('application/json');
    expect(calledOptions.body).toBe(JSON.stringify({ name: 'Campus MN' }));
  });

COMMANDS RUN: yarn jest src/client/fonts/repositories/fontRepository.test.ts
TEST OUTPUT: RED - TypeError: repository.addFont is not a function

NEXT STEP: Add addFont method to fontRepository that sends a POST request to /api/fonts.

=== GREEN PHASE ===
CHANGESET:
  const addFont = async (name: string): Promise<any> => {
    const response = await fetch('/api/fonts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ name })
    });

    if (!response.ok) {
      throw new Error(`Failed to add font: ${response.statusText}`);
    }

    return await response.json();
  };

  return {
    getFonts,
    addFont
  };

COMMANDS RUN: yarn jest src/client/fonts/repositories/fontRepository.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.2: Step 3: Frontend: Repository: adds a font
USER DECISION: committed

GOAL: adds a font
PLAN STEP: 4
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/service/fonts/controllers/fontController.test.ts - adds a font
CHANGESET:
  it('adds a font', async () => {
    const newFont = { id: 'campus-mn', name: 'Campus MN' };
    const fakeAddFontCommand = {
      execute: async (name: string) => {
        if (name === 'Campus MN') return newFont;
        return null;
      }
    };
    const fakeListFontsCommand = {
      execute: async () => []
    };

    const controller = fontController(fakeListFontsCommand, fakeAddFontCommand);
    const result = await controller.addFont('Campus MN');

    expect(result).toEqual(newFont);
  });

COMMANDS RUN: yarn jest src/service/fonts/controllers/fontController.test.ts
TEST OUTPUT: RED - TypeError: controller.addFont is not a function

NEXT STEP: Update fontController to accept AddFont use case and implement addFont method.

=== GREEN PHASE ===
CHANGESET:
  const addFont = async (name: string): Promise<any> => {
    return await addFontCommand.execute(name);
  };

COMMANDS RUN: yarn jest src/service/fonts/controllers/fontController.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.2: Step 4: Backend: Controller: adds a font
USER DECISION: committed and pushed

GOAL: adds a font
PLAN STEP: 5
----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/service/fonts/use-cases/AddFont.test.ts - adds a font
CHANGESET:
  it('adds a font', async () => {
    const font = { id: 'campus-mn', name: 'Campus MN', slug: 'campus-mn' };
    let calledSlug = '';
    const fakeRepository = {
      fetch: async (slug: string) => {
        calledSlug = slug;
        return font;
      },
      getAll: async () => [],
      save: async () => {}
    };

    const result = await AddFont(fakeRepository, 'Campus MN');

    expect(result).toEqual(font);
    expect(calledSlug).toBe('campus-mn');
  });

COMMANDS RUN: yarn jest src/service/fonts/use-cases/AddFont.test.ts
TEST OUTPUT: RED - Cannot find module './AddFont'

NEXT STEP: Create AddFont use case as a simple async function that slugifies the name and calls repository.fetch.

=== GREEN PHASE ===
CHANGESET:
export const AddFont = async (repository: any, name: string): Promise<any> => {
  const slug = name.toLowerCase().replace(/ /g, '-');
  return await repository.fetch(slug);
};

COMMANDS RUN: yarn jest src/service/fonts/use-cases/AddFont.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.1.2: Step 5: Backend: UseCase: adds a font
USER DECISION:


PLAN:
1. Frontend Component: FontSelector
   - Goal: Update FontSelector to support adding fonts (Combobox UI).
   - Minimal implementation: Add input and button to FontSelector.
   - Files expected to change: src/client/fonts/components/FontSelector.tsx

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 1: Frontend: Component: adds a font

2. Frontend Hook: useFonts
   RED:
   - Test name: adds a font
   - Location: src/client/fonts/hooks/useFonts.test.ts
   - Intent: Verify that useFonts returns an addFont function that updates the local state.

   GREEN:
   - Minimal implementation: Update useFonts to return addFont and use repository.addFont.
   - Files expected to change: src/client/fonts/hooks/useFonts.ts

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 2: Frontend: Hook: adds a font

3. Frontend Repository: fontRepository
   RED:
   - Test name: adds a font
   - Location: src/client/fonts/repositories/fontRepository.test.ts
   - Intent: Verify that addFont persists a new font.

   GREEN:
   - Minimal implementation: Add addFont to fontRepository using fetch with POST.
   - Files expected to change: src/client/fonts/repositories/fontRepository.ts

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 3: Frontend: Repository: adds a font

4. Backend Controller: fontController
   RED:
   - Test name: adds a font
   - Location: src/service/fonts/controllers/fontController.test.ts
   - Intent: Verify that addFont orchestrates adding a font.

   GREEN:
   - Minimal implementation: Add addFont to fontController.
   - Files expected to change: src/service/fonts/controllers/fontController.ts

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 4: Backend: Controller: adds a font

5. Backend UseCase: AddFont
   RED:
   - Test name: adds a font
   - Location: src/service/fonts/use-cases/AddFont.test.ts
   - Intent: Verify that the UseCase fetches and persists a font by name.

   GREEN:
   - Minimal implementation: Create AddFont UseCase.
   - Files expected to change: src/service/fonts/use-cases/AddFont.ts

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 5: Backend: UseCase: adds a font

6. Backend Routing & Body Parsing
   RED:
   - Test name: adds a font
   - Location: src/service/app.test.ts
   - Intent: Verify that the system accepts font additions via HTTP.

   GREEN:
   - Minimal implementation: Add koa-bodyparser and update router to handle POST /api/fonts.
   - Files expected to change: src/service/app.ts, package.json

   COMMIT:
   - Proposed message: feat: FR.1.2: Step 6: Backend: App: adds a font

7. Cleanup & Verification
   - Run all tests.
   - Fix linting errors.
   COMMIT:
   - Proposed message: feat: FR.1.2: cleanup: final verification
GOAL: remembers the user's input text
PLAN STEP: 2.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/components/TextPreview/usePreview.test.ts - remembers the user's input text
CHANGESET:
import { renderHook, act } from '@testing-library/react';
import { usePreview } from './usePreview';

describe('Preview Hook', () => {
  test('remembers the user\'s input text', () => {
    const { result } = renderHook(() => usePreview());

    act(() => {
      result.current.setText('Hello World');
    });

    expect(result.current.text).toBe('Hello World');
  });
});

COMMANDS RUN: yarn test src/client/components/TextPreview/usePreview.test.ts
TEST OUTPUT: RED - Cannot find module './usePreview'

NEXT STEP: Create usePreview.ts with text state

=== GREEN PHASE ===
CHANGESET:
import { useState } from 'react';

export const usePreview = () => {
  const [text, setText] = useState('');

  return {
    text,
    setText
  };
};

COMMANDS RUN: yarn test src/client/components/TextPreview/usePreview.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.2: Step 2: Frontend: Hook: remembers input text
USER DECISION: commit

=== REFACTOR PHASE ===
REFRACTORING NOTES:
No refactoring was necessary

GOAL: tracks the currently selected font for preview
PLAN STEP: 3.2

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/components/TextPreview/usePreview.test.ts - tracks the currently selected font for preview
CHANGESET:
  test('tracks the currently selected font for preview', () => {
    const { result } = renderHook(() => usePreview());
    const font = { id: 'octin-sports', name: 'Octin Sports', css_stack: '"octin-sports"' };

    act(() => {
      result.current.setSelectedFont(font);
    });

    expect(result.current.selectedFont).toEqual(font);
  });

COMMANDS RUN: yarn test src/client/components/TextPreview/usePreview.test.ts
TEST OUTPUT: RED - TypeError: result.current.setSelectedFont is not a function

NEXT STEP: Add selectedFont state to usePreview.ts

=== GREEN PHASE ===
CHANGESET:
export const usePreview = () => {
  const [text, setText] = useState('');
  const [selectedFont, setSelectedFont] = useState<Font | null>(null);

  return {
    text,
    setText,
    selectedFont,
    setSelectedFont
  };
};

COMMANDS RUN: yarn test src/client/components/TextPreview/usePreview.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.2: Step 3: Frontend: Hook: tracks selected font
USER DECISION: commit

=== REFACTOR PHASE ===
REFRACTORING NOTES:
No refactoring was necessary

=== COMMIT (REFACTOR) ===
PROPOSED COMMIT: feat: FR.2: refactor: consolidate Font interface
USER DECISION: commit

GOAL: renders live text preview in App.tsx
PLAN STEP: 4.2

=== GREEN PHASE ===
CHANGESET:
  const preview = usePreview();

  return (
    ...
              <FontSelector 
                useFonts={boundUseFonts} 
                onSelect={preview.setSelectedFont} 
              />
    ...
            <TextPreview 
              text={preview.text} 
              setText={preview.setText} 
              selectedFont={preview.selectedFont} 
            />

VERIFICATION: Manual verification (UI tests disallowed)

=== COMMIT ===
PROPOSED COMMIT: feat: FR.2: Step 4: Frontend: App: renders live text preview
USER DECISION: commit

=== CLEANUP & VERIFICATION ===
- Ran full test suite
- Fixed linting errors
- Updated guidelines for UI tests and hook placement

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.2: cleanup: final verification of text preview
USER DECISION: commit

GOAL: fetches base svg
PLAN STEP: 2

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/components/useSVG.test.ts - fetches base svg

=== GREEN PHASE ===
CHANGESET: useSVG.ts created

COMMANDS RUN: yarn test src/client/components/useSVG.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.3.1: Step 2: Frontend: Hook: fetches base svg
USER DECISION: 

=== REFACTOR PHASE ===
REFRACTORING NOTES:
No refactoring was necessary

PLAN:
1. Frontend: Hook - useSVG ✓
   RED:
   - Test name: fetches tight outline svg
   - Location: src/client/components/useSVG.test.ts
   - Intent: Update the hook to fetch and return the tightOutlineSVG from the backend API using type=tight. ✓

   GREEN:
   - Minimal implementation: Update useSVG.ts to fetch both base and tight SVGs. ✓
   - Files expected to change: src/client/components/useSVG.ts ✓

   COMMIT:
   - Proposed message: feat: FR.3.2: Step 1: Frontend: Hook: fetches tight outline svg ✓

   REFACTOR:
   - Candidate refactors: None anticipated.
   - Files expected to change: None.

2. Backend: Use Case - Generate Tight Outline SVG
   TDD Increment 2
   RED:
   - Test name: generates tight outline svg
   - Location: src/service/svg/use-cases/GenerateTightOutlineSVG.test.ts
   - Intent: Define a use case that orchestrates tight outline generation.

   GREEN:
   - Minimal implementation: Create GenerateTightOutlineSVG use case.
   - Files expected to change: src/service/svg/use-cases/GenerateTightOutlineSVG.ts

   COMMIT:
   - Proposed message: feat: FR.3.2: Step 2: Service: UseCase: generates tight outline svg

   REFACTOR:
   - Candidate refactors: None anticipated.
   - Files expected to change: None.

3. Backend: Domain - SVG Generation (Contour)
   TDD Increment 3
   RED:
   - Test name: generates tight outline svg from text
   - Location: src/service/svg/domain/svgGenerator.test.ts
   - Intent: Update svgGenerator to support a type parameter and render a stroke behind the text for the tight outline.

   GREEN:
   - Minimal implementation: Add options to svgGenerator to handle stroke width/color.
   - Files expected to change: src/service/svg/domain/svgGenerator.ts

   COMMIT:
   - Proposed message: feat: FR.3.2: Step 3: Service: Domain: generates tight outline svg from text

   REFACTOR:
   - Candidate refactors: None anticipated.
   - Files expected to change: None.

4. Backend Integration (Non-TDD)
   - Goal: Update fontController.ts and app.ts to expose the new use case.
   - Changes: src/service/fonts/controllers/fontController.ts, src/service/app.ts.

5. App Integration
   - Goal: Add another SVGPreview component in App.tsx to display the "Tight Outline SVG".
   - Changes: Update src/client/App.tsx.
   - Verification: Manual verification in browser.

6. Cleanup & Verification
   - Run all tests.
   - Fix linting errors.
   - Mark task as [COMPLETED] in tasks.md.

   COMMIT:
   - Proposed message: feat: FR.3.2: cleanup: tight outline svg generation
PLAN:
1. Frontend: Domain - downloadService (TDD)
   RED:
   - Test name: triggers download of string content
   - Location: src/client/domain/downloadService.test.ts
   - Intent: Verify that calling the download function creates a link and triggers a click to download the content as a file.
   GREEN:
   - Minimal implementation: Create downloadService.ts.
   - Files expected to change: src/client/domain/downloadService.ts
   COMMIT:
   - Proposed message: feat: FR.4.1: Step 1: Frontend: Domain: download utility
2. Frontend: Component - SVGPreview
   - Goal: Add a Download button to the SVGPreview component.
3. App Integration
4. Cleanup & Verification

GOAL: triggers download of string content
PLAN STEP: 1

----------------------------------------------------------------------

=== RED PHASE ===

PLAN:
Task FR.4.1: Download SVG

OUTSIDE-IN FLOW:
App.tsx -> SVGPreview.tsx -> downloadService.ts

PLAN:
1. Frontend: Component Layer - SVGPreview Update (Non-TDD Scaffold)
   - Goal: Add `onDownload` prop and clickable styles to SVGPreview.
   - Files: `src/client/components/SVGPreview.tsx`
2. Frontend: App Layer - Integration (Non-TDD)
   - Goal: Implement `handleDownload` in `App.tsx` and pass it to SVGPreview components.
   - Files: `src/client/App.tsx`
3. Frontend: Domain Layer - downloadService (TDD)
   - TDD Increment 1
   RED:
   - Test name: triggers a download
   - Location: `src/client/domain/downloadService.test.ts`
   - Intent: Define `downloadSVG` that triggers a browser download.
   GREEN:
   - Minimal implementation using Blob and a temporary link.
   - Files: `src/client/domain/downloadService.ts`
   COMMIT:
   - Proposed message: feat: FR.4.1: Step 3: Frontend: Domain: triggers a download
   REFACTOR:
   - Ensure code quality and adherence to domain language.
4. Cleanup & Verification
   - Run all tests.
   - Fix linting errors.
   - Mark task as [COMPLETED] in `tasks.md`.
GOAL: Clicking a Base, Tight, or Outer thumbnail downloads its full-resolution SVG file
PLAN STEP: 3.1

----------------------------------------------------------------------

=== RED PHASE ===
TEST ADDED: src/client/domain/downloadService.test.ts - triggers a download
CHANGESET:
    test('triggers a download', () => {
    const svgString = '<svg>test</svg>';
    const filename = 'test.svg';
    
    // Setup simple stubs for browser APIs
    const createdElements: any[] = [];
    const originalCreateElement = document.createElement.bind(document);
    
    // @ts-ignore
    document.createElement = (tagName: string) => {
      const el = originalCreateElement(tagName);
      if (tagName === 'a') {
        const fakeLink = {
          tagName: 'A',
          href: '',
          download: '',
          click: () => { fakeLink.clicked = true; },
          clicked: false
        };
        createdElements.push(fakeLink);
        return fakeLink;
      }
      return el;
    };

    // @ts-ignore
    window.URL.createObjectURL = () => 'blob:url';
    // @ts-ignore
    window.URL.revokeObjectURL = () => {};

    downloadSVG(svgString, filename);

    expect(createdElements.length).toBe(1);
    expect(createdElements[0].download).toBe(filename);
    expect(createdElements[0].href).toBe('blob:url');
    expect(createdElements[0].clicked).toBe(true);

    // Cleanup
    document.createElement = originalCreateElement;
  });

COMMANDS RUN: yarn test src/client/domain/downloadService.test.ts
TEST OUTPUT: RED - expect(received).toBe(1) Received: 0

NEXT STEP: Implement downloadSVG using Blob and a temporary link.

=== GREEN PHASE ===
CHANGESET:
export const downloadSVG = (svgString: string, filename: string): void => {
  const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

COMMANDS RUN: yarn test src/client/domain/downloadService.test.ts
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.4.1: Step 3: Frontend: Domain: triggers a download
USER DECISION: commit

=== REFACTOR PHASE ===
REFRACTORING NOTES:
No refactoring was necessary for the domain function. Integrated the service into App.tsx.

CHANGESET:
- import { downloadSVG } from './domain/downloadService';
- Replace stub in App.tsx with actual service call.

COMMANDS RUN: yarn test
TEST OUTPUT: GREEN - All tests passing

=== CLEANUP & VERIFICATION ===
- Ran full test suite
- Verified TypeScript compilation
- Marked task as [COMPLETED] in tasks.md

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.4.1: cleanup: svg download functionality
USER DECISION: commit

GOAL: generates tight outline as real path geometry
PLAN STEP: 1.1

---
=== RED PHASE ===
TEST ADDED: src/service/svg/domain/svgGenerator.test.ts - generates tight outline as a filled path without strokes
COMMANDS RUN: yarn test src/service/svg/domain/svgGenerator.test.ts
TEST OUTPUT: RED - tightSvg contains stroke="black" and stroke-width="8"
NEXT STEP: Update svgGenerator.ts to generate a new path with offset geometry
=== GREEN PHASE ===
- Implemented real path geometry (offset contours) using clipper-lib in svgGenerator.ts
- Updated svgGenerator.test.ts to verify filled paths instead of strokes
COMMANDS RUN: yarn test src/service/svg/domain/svgGenerator.test.ts
TEST OUTPUT: GREEN - All tests passing
=== REFACTOR PHASE ===
- Extracted getOffsetPath logic into src/service/svg/domain/pathOffsetter.ts
COMMANDS RUN: yarn test src/service/svg/domain/svgGenerator.test.ts
TEST OUTPUT: GREEN - All tests passing
=== CLEANUP & VERIFICATION ===
- Ran full test suite
- Fixed TS error in src/client/App.tsx and src/client/hooks/useDownload.ts
- Updated tasks.md to mark FR.3.2 and FR.3.3 as [COMPLETED]
- Verified tsc --noEmit passes

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.3.2: cleanup: tight and outer outline generation
=== GREEN PHASE ===
- Updated getOffsetPath in src/service/svg/domain/pathOffsetter.ts to support hole filtering
- Enabled hole filtering for "outer" outlines in src/service/svg/domain/svgGenerator.ts
COMMANDS RUN: yarn test src/service/svg/domain/svgGenerator.test.ts
TEST OUTPUT: GREEN - All tests passing
=== REFACTOR PHASE ===
- Extracted hole detection logic into isHole helper in src/service/svg/domain/pathOffsetter.ts
COMMANDS RUN: yarn test src/service/svg/domain/svgGenerator.test.ts
TEST OUTPUT: GREEN - All tests passing
=== CLEANUP & VERIFICATION ===
- Ran full test suite
- Verified tsc --noEmit passes
- Confirmed gap filling for "outer" outline

=== COMMIT (CLEANUP) ===
PROPOSED COMMIT: feat: FR.3.3: cleanup: filled outer outline
=== GREEN PHASE ===
CHANGESET:
import { useState, useCallback } from 'react';

export const useImageUpload = () => {
  const [imageSrc, setImageSrc] = useState<string | null>(null);

  const handleImageSelect = useCallback((file: File) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      setImageSrc(e.target?.result as string);
    };
    reader.readAsDataURL(file);
  }, []);

  return {
    imageSrc,
    handleImageSelect
  };
};

COMMANDS RUN: yarn jest src/client/components/ImageToSVG/useImageUpload.test.tsx
TEST OUTPUT: GREEN - All tests passing

=== COMMIT ===
PROPOSED COMMIT: feat: FR.6.1: Step 2: Frontend: Hook: stores uploaded image
